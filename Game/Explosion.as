package Game{	import flash.display.Shape;	import flash.display.BitmapData;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.utils.Dictionary;		public final class Explosion	{		private static var Pool:Vector.<Explosion> = new Vector.<Explosion>();		private static var Cache:Dictionary = new Dictionary();		private static const Loc:Rectangle = new Rectangle();						public static function tick(image:BitmapData, pieces:Vector.<ExplosionPiece>):void		{			if(pieces.length == 0)				return;							var i:int;			var piece:ExplosionPiece;							for(i=pieces.length-1; i>-1; i--)			{				piece = pieces[i];				piece.y += piece.speedY;				piece.x += piece.speedX;								if(piece.gravity)				{					piece.speedY += 0.5;					Loc.width = 3;					Loc.height = 3;				}				else				{					piece.ticks--;					Loc.width = 2;					Loc.height = 2;										if(piece.ticks < 0)					{						pieces.splice(i, 1);						ExplosionPiece.dispose(piece);													continue;					}				}								if(piece.x > -1 && piece.x < 420 && piece.y > -1 && piece.y < 400)				{					Loc.x = piece.x-1;					Loc.y = piece.y-1;									image.fillRect(Loc, piece.color);				}				else				{					pieces.splice(i, 1);					ExplosionPiece.dispose(piece);					continue;				}			}		}				public static function explode(monster:Minion, particles:Vector.<ExplosionPiece>):void		{			var placeholderpieces:Vector.<ExplosionPiecePlaceholder>;			var key:String = monster.type + "_" + monster.color;						if(Cache[key] == null)			{				placeholderpieces =  new Vector.<ExplosionPiecePlaceholder>();				var placeholder:ExplosionPiecePlaceholder;				var x:int;				var y:int;				for(x=0; x<20; x++)				{					for(y=0; y<20; y++)					{						if(monster.image.getPixel32(x, y) != 0)						{							placeholder = new ExplosionPiecePlaceholder();							placeholder.x = x;							placeholder.y = y;							placeholder.color = monster.image.getPixel32(x, y);							placeholderpieces.push(placeholder);						}					}				}								Cache[key] = placeholderpieces;			}			else			{				placeholderpieces = Cache[key];			}			var r:Number = 180 / Math.PI;			var r2:Number = Math.PI / 180;			var piece:ExplosionPiece;			var ecenter:Point = new Point(monster.centerX, monster.centerY);			var piececoord:Point = new Point();			var angle:Number;						for(var i:int=placeholderpieces.length-1; i>-1; i--)			{				placeholder = placeholderpieces[i];					piececoord.x = monster.x + placeholder.x;				piececoord.y = monster.y + placeholder.y;				angle = Math.atan2(monster.centerY - piececoord.y, monster.centerX - piececoord.x) * r;							piece = ExplosionPiece.create();				piece.speedX = -Math.cos(angle * r2) * (3 / Math.random());				piece.speedY = -Math.sin(angle * r2) * (2 / Math.random());				piece.x = piececoord.x;				piece.y = piececoord.y;				piece.color = placeholder.color;				piece.gravity = true;				particles.push(piece);			}		}				public static function implode(monster:Minion, pieces:Vector.<ExplosionPiece>):void		{			var numparticles:int = 24;			var angleinc:Number = 360 / numparticles;			var angle:Number = 0;			var piece:ExplosionPiece;			var color:uint = monster.color;			for(var i:int=0; i<numparticles; i++) 			{				piece = ExplosionPiece.create();				piece.speedY = Math.sin(angle * Math.PI / 180) * 4;				piece.speedX = Math.cos(angle * Math.PI / 180) * 4;				piece.x = monster.x + 10 + (piece.speedX * 8);				piece.y = monster.y + 10 + (piece.speedY * 8);				piece.speedX *= -1;				piece.speedY *= -1;				piece.color = color; 				piece.gravity = false;				piece.ticks = 8;								pieces.push(piece);				angle += angleinc;			}						}	}}