package Game{	import flash.display.BitmapData;	import flash.geom.Point;	import flash.geom.Rectangle;	import Assets.Minions;	import Playtomic.Log;		public final class Minion	{		private static var Pool:Vector.<Minion> = new Vector.<Minion>();		private static var Images:Vector.<Vector.<BitmapData>> = new Vector.<Vector.<BitmapData>>(4, true);		public static var Blue:Vector.<BitmapData> = new Vector.<BitmapData>(16, true);		private static var Red:Vector.<BitmapData> = new Vector.<BitmapData>(16, true);		private static var Green:Vector.<BitmapData> = new Vector.<BitmapData>(16, true);		private static var Black:Vector.<BitmapData> = new Vector.<BitmapData>(16, true);				public var dead:Boolean = false;		public var frame:int = 0;		public var hitPoints:int;		public var hitPointsBase:int;		public var color:uint;		public var type:int;		public var pathIndex:int;		public var spawns:Boolean;		public var flies:Boolean;		public var x:int;		public var y:int;		public var gridX:int;		public var gridY:int;		public var image:BitmapData;		public var moved:int;		public var moveX:int;		public var moveY:int;		public var centerX:int;		public var centerY:int;				public var speed:int;		public var path:Vector.<Point>;		public var wave:Game.Wave;		public var noBonus:Boolean;		public var startOffset:int = 0;				public static function create(mode:int):Minion		{			var monster:Minion = Pool.length > 0 ? Pool.pop() : new Minion();			monster.dead = false;			monster.frame = 0;			monster.noBonus = false;			monster.moveX = 0;			monster.moveY = 0;			monster.pathIndex = 0;					monster.startOffset = mode == 0 ? 0 : 3 - Math.random() * 6;			return monster;		}				public static function spawn(wavenumber:int, waves:Vector.<Wave>, monsters:Vector.<Minion>, startx:int, starty:int, map:Vector.<Vector.<AStarNode>>, world:Game.World):void		{			if((wavenumber == -1 || waves.length == 0) && world.plane == null)				return;							if(world.plane != null && waves.length == 0)			{				world.plane.x += 4;								if(world.plane.x >= 600)				{					world.plane.parent.removeChild(world.plane);					world.plane = null;				}			}						if(waves.length == 0)				return;			var wave:Game.Wave;			var monster:Minion;			var config:MinionConfig;			var i:int;			var wmax:int = wavenumber+1;			var wstart:int = wmax - waves[0].num;						if(wstart >= waves.length)				wstart = waves.length - 1;							if(world.plane != null)			{				world.plane.x += 4;								if(world.plane.x >= 600)				{					world.plane.parent.removeChild(world.plane);					world.plane = null;				}				else				{									if(world.plane.x == -400 || world.plane.x == -320 || world.plane.x == -240 || world.plane.x == -140)					{						var gx:int = (world.plane.x + 360) / 20;						var j:int;						monster = create(world.mode);						monster.gridX = startx;						monster.gridY = starty;						world.createPath(monster, map);												var ppath:Vector.<Point> = monster.path;						var bpath:Vector.<Boolean> = new Vector.<Boolean>(ppath.length, true);												for(i=0; i<bpath.length; i++)							bpath[i] = true;						for(i=0; i<5; i++)						{							monster = create(world.mode);							monster.type = int(Math.random() * 10) + 1;							monster.image = Images[waves[wstart].mColor][monster.type - 1];							monster.color = waves[wstart].color;							monster.hitPoints = (waves[wstart].hitPoints / waves[wstart].total);							monster.hitPointsBase = monster.hitPoints;							monster.spawns = false;							monster.flies = false;							monster.x = gx * 20;							monster.gridX = gx;							monster.speed = 2;							monster.wave = wave;							monster.spawns = false;							monster.path = ppath;							monster.pathIndex = -1;							monster.wave = waves[wstart];														for(j=ppath.length -1; j>-1 && monster.pathIndex == -1; j--)							{								if(ppath[j].x == gx && bpath[j])								{									monster.pathIndex = j;									monster.gridY = ppath[j].y;									monster.y = monster.gridY * 20;									bpath[j] = false;								}							}														if(monster.pathIndex != -1)							{															monsters.push(monster);								setDirection(monster, monster.pathIndex);							}						}					}				}							}			for(i=wstart; i>-1; i--)			{				wave = waves[i];								if(wave.tunnel && !wave.initialized)				{					// check if it's possible					if(world.mapCheck(wave.tunnelX, wave.tunnelY, map, monsters) == false)					{						monster = create(world.mode);						monster.gridX = startx;						monster.gridY = starty;						world.createPath(monster, map);												var cindex:int = Math.random() * (monster.path.length / 2);						wave.tunnelX = monster.path[cindex].x;						wave.tunnelY = monster.path[cindex].y;					}					wave.special = new Hole();					wave.special.x = wave.tunnelX * 20 + 10;					wave.special.y = wave.tunnelY * 20 + 10;					world.addChild(wave.special);					wave.initialized = true;					continue;				}								if(wave.num % 20 == 0 && !wave.initialized && world.plane == null)				{					SoundManager.play("Plane");					world.plane = new Plane();					world.plane.x = -600;					world.plane.y = -100;					world.addChild(world.plane);					wave.initialized = true;				}								if(wave.tunnel && wave.special.currentFrame < 5)					continue;								if(wave.remaining == 0)					continue;								wave.spawnTimer--;								if(wave.spawnTimer > 0)					continue;									wave.remaining--;				wave.spawnTimer = wave.spawnInterval;								config = MinionConfig.Blue[wave.type-1];								monster = create(world.mode);				monster.image = Images[wave.mColor][wave.type-1];				monster.color = wave.color;				monster.type = wave.type;				monster.hitPoints = (wave.hitPoints / wave.total);				monster.hitPointsBase = monster.hitPoints;				monster.spawns = config.spawns;				monster.flies = config.flies;				monster.x = wave.tunnel ? wave.tunnelX * 20 : startx;				monster.y = wave.tunnel ? wave.tunnelY * 20 : starty + (monster.startOffset * 20);				monster.gridX = monster.x / 20;				monster.gridY = monster.y / 20;				monster.speed = config.speed;				monster.wave = wave;				monster.spawns = config.spawns;				monsters.push(monster);								world.createPath(monster, map, wave.tunnel);				setDirection(monster, monster.pathIndex);								if(wave.num == wmax)				{					world.waveIndicator.update(wavenumber, wave.remaining, wave.total);				}								if(wave.remaining == 0)				{					if(wave.special)					{						wave.special.play();					}										waves.splice(i, 1);				}			}		}				public static function escape(world:Game.World, monster:Minion):void		{			world.lives--;			monster.dead = true;			//SoundManager.Play("TowerCreepEscape");			dispose(monster);						// Here we log the escape			Log.LevelCounterMetric("escaped_" + (world.mode == 0 ? "path" : "free"), world.waveNumber);		}				public static function setDirection(monster:Minion, nextpath:int=0):void		{			if(monster.path.length < 2 || nextpath >= monster.path.length)			{				monster.moveX = monster.speed;				monster.moveY = 0;			}			else			{				monster.moveX = monster.gridX > monster.path[nextpath].x ? -monster.speed : (monster.gridX < monster.path[nextpath].x ? monster.speed : 0);				monster.moveY = monster.gridY > monster.path[nextpath].y ? -monster.speed : (monster.gridY < monster.path[nextpath].y ? monster.speed : 0);			} 		}				public static function respawn(monster:Minion, particles:Vector.<ExplosionPiece>):void		{			monster.frame++;			if(monster.frame == 1)			{				Explosion.implode(monster, particles);			}											else if(monster.frame == 9)			{				monster.spawns = false;				monster.dead = false;				monster.frame = 0;				monster.hitPoints = monster.hitPointsBase / 1.5;				monster.noBonus = true;			}		}				public static function dispose(minion:Minion):void		{			Pool.push(minion);		}				public static function initialize():void		{						var minions:BitmapData = new Assets.Minions(320, 80);			var zeropoint:Point = new Point();			var copyrect:Rectangle = new Rectangle(0, 0, 20, 20);			var index:int = 0;			var x:int;			var y:int;			var i:int;						// sprites			for(y=0; y<4; y++)			{				for(x=0; x<4; x++)				{					copyrect.x = x * 20;					copyrect.y = y * 20;										// blue					Blue[index] = new BitmapData(20, 20, true, 0x00000000);					Blue[index].copyPixels(minions, copyrect, zeropoint, null, null, true);										// red					copyrect.x += 80;					Red[index] = new BitmapData(20, 20, true, 0x00000000);					Red[index].copyPixels(minions, copyrect, zeropoint, null, null, true);										// black					copyrect.x += 80;					Black[index] = new BitmapData(20, 20, true, 0x00000000);					Black[index].copyPixels(minions, copyrect, zeropoint, null, null, true);										// green					copyrect.x += 80;					Green[index] = new BitmapData(20, 20, true, 0x00000000);					Green[index].copyPixels(minions, copyrect, zeropoint, null, null, true);										index++;				}			}						Images[0] = Blue;			Images[1] = Red;			Images[2] = Black;			Images[3] = Green;		}	}}