package Game{	import flash.display.BitmapData;	import flash.geom.Point;	import flash.geom.Rectangle;	import Assets.Missiles;		public final class Missile	{		private static var Pool:Vector.<Missile> = new Vector.<Missile>();		public static var Red:BitmapData;		public static var Blue:BitmapData;		public static var Black:BitmapData;		public static var Green:BitmapData;				public var image:BitmapData;		public var damage:int;		public var color:uint;		public var x:Number;		public var y:Number;		public var gridX:int;		public var gridY:int;		public var centerX:Number;		public var centerY:Number;		public var moveX:Number;		public var moveY:Number;		public var origin:Tower;				public static function create(tower:Tower, monster:Minion, offset:int=0, direction:int=0):Missile		{			var missile:Missile = getInstance();			missile.x = tower.centerX - 3 - offset;			missile.y = tower.centerY - 3 - offset;			missile.gridX = missile.x / 20;			missile.gridY = missile.y / 20;			missile.damage = tower.damage;			missile.origin = tower;			missile.color = tower.color;			missile.image = tower.missileImage;						if(tower.config.behaviorType != BehaviorTypes.Spray)			{							// distance				var dx:int = monster.centerX - tower.centerX;				var dy:int = monster.centerY - tower.centerY;				var d:Number = Math.sqrt((dx * dx) + (dy * dy));					// predicted location of monster in d over speed ticks				var d2:Number = Math.ceil(d / tower.config.missileSpeed);				var dx2:Number = monster.centerX + (d2 * monster.moveX) - tower.centerX;				var dy2:Number = monster.centerY + (d2 * monster.moveY) - tower.centerY;					// missile path				var p:Number = Math.atan2(dy2, dx2);							missile.moveX = tower.config.missileSpeed * Math.cos(p);				missile.moveY = tower.config.missileSpeed * Math.sin(p);			}			else			{				if(direction == 2 || direction == 3 || direction == 4)				{					missile.moveX = 3;				}				else if(direction == 6 || direction == 7 || direction == 8)				{					missile.moveX = -3;				}				else				{					missile.moveX = 0;				}								if(direction == 8 || direction == 1 || direction == 2)				{					missile.moveY = -3;				}				else if(direction == 4 || direction == 5 || direction == 6)				{					missile.moveY = 3;				}				else				{					missile.moveY = 0;				}			}						return missile;		}								public static function tick(image:BitmapData, missiles:Vector.<Missile>, monsters:Vector.<Minion>, particles:Vector.<ExplosionPiece>, textblocks:Vector.<FadingTextPiece>, world:Game.World):void		{			if(missiles.length == 0)				return;			var missile:Missile;			var monster:Minion;			var monster2:Minion;			var i:int;			var j:int;			var d:Number;			var dx:Number;			var dy:Number;			var p:Point = new Point();			var b:int;			var gx:int;			var gy:int;			var abs:Function = Math.abs;			missileloop: for(i=missiles.length-1; i>-1; i--)			{				missile = missiles[i];				missile.x += missile.moveX;				missile.y += missile.moveY;				missile.centerX = missile.x + 3;				missile.centerY = missile.y + 3;				missile.gridX = missile.x / 20;				missile.gridY = missile.y / 20;								// left stage				if(missile.x + 6 < 0 || missile.y + 6 < 0 || missile.x > 400 || missile.y > 380)				{					missiles.splice(i, 1);					dispose(missile);					continue;				}								// check if hit monster						if(monsters.length == 0)					continue;				monsterloop: for(j=monsters.length-1; j>-1; j--)				{					monster = monsters[j];										if(monster.dead || (missile.color != monster.color && missile.origin.type != 8))						continue;											// grid range check					gx = abs(monster.gridX - missile.gridX);					gy = abs(monster.gridY - missile.gridY);										if(gx > 1 || gy > 1)						continue;										// distance to monster					dx = monster.centerX - missile.centerX;					dy = monster.centerY - missile.centerY;					d = Math.sqrt((dx * dx) + (dy * dy));								if(d > 10)					{						continue monsterloop;					}					monster.hitPoints -= missile.damage;										if(monster.hitPoints < 1)					{						if(missile.origin.parent)						{							missile.origin.kills++;						}												monster.dead = true;												if(monster.spawns == false)						{							Explosion.explode(monster, particles);							monsters.splice(j, 1);						}												if(monster.noBonus == false)						{							b = monster.wave.money / monster.wave.total							world.updateMoney(b);							textblocks.push(FadingTextPiece.create("+" + b, monster.x, monster.y, monster.color));						}											SoundManager.play("Pop" + int(1 + (Math.random() * 4)));						world.kills++;					}										// don't remove boom boom / big three missiles					if(missile.origin.config.behaviorType != BehaviorTypes.Multi2 && missile.origin.config.behaviorType != BehaviorTypes.Multi3)					{						missiles.splice(i, 1);						dispose(missile);					}										break monsterloop;				}								// render				p.x = missile.x;				p.y = missile.y;				image.copyPixels(missile.image, missile.image.rect, p, null, null, true);			}		}				private static function getInstance():Missile		{			return Pool.length > 0 ? Pool.pop() : new Missile();		}				public static function dispose(missile:Missile):void		{			missile.origin = null;			Pool.push(missile);		}				public static function initialize():void		{			var missiles:BitmapData = new Assets.Missiles(12, 12);			var zeropoint:Point = new Point(0, 0);			var copyrect:Rectangle = new Rectangle(0, 0, 6, 6);						Black = new BitmapData(6, 6, true, 0x00000000);			Black.copyPixels(missiles, copyrect, zeropoint, null, null, true);						copyrect.x = 6;						Red = new BitmapData(6, 6, true, 0x00000000);			Red.copyPixels(missiles, copyrect, zeropoint, null, null, true);						copyrect.y = 6;						Green = new BitmapData(6, 6, true, 0x00000000);			Green.copyPixels(missiles, copyrect, zeropoint, null, null, true);						copyrect.x = 0;						Blue = new BitmapData(6, 6, true, 0x00000000);			Blue.copyPixels(missiles, copyrect, zeropoint, null, null, true);		}	}}