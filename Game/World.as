package Game{		import flash.display.Sprite;	import flash.display.MovieClip;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.KeyboardEvent;	import flash.geom.Rectangle;	import flash.geom.Point;	import flash.text.TextField;	import flash.ui.Keyboard;	import Assets.Path;	import Assets.EndPoints;	import Playtomic.Log;		public final class World extends BaseScreen	{		private const towerButtons:Vector.<TowerButton> = new Vector.<TowerButton>(8, true);				public var towers:Vector.<Tower> = new Vector.<Tower>();		public var monsters:Vector.<Minion> = new Vector.<Minion>();		public var missiles:Vector.<Missile> = new Vector.<Missile>();		public var particles:Vector.<ExplosionPiece> = new Vector.<ExplosionPiece>();				public var textBlocks:Vector.<FadingTextPiece> = new Vector.<FadingTextPiece>();		public var map:Vector.<Vector.<AStarNode>>;				public var towerTick:Function;		public var missileTick:Function;		public var minionSpawn:Function;		public var minionTick:Function;		public var mapCheck:Function;		public var mapLock:Function;		public var mapUnlock:Function;		public var pause:Boolean = false;		public var mapClip:MovieClip;		public var underlay:Bitmap;		public var overlay:Bitmap;		public var placing:int;		public var viewing:Tower;		public var waveNumber:int = -1;		public var waves:Vector.<Wave>;		public var money:int = 0;		public var lives:int;		public var kills:int = 0;		public var mode:int;		public var waveTarget:int = 10;		public var shiftDown:Boolean = false;		public var gridSize:int;		public var spawnY:int;		public var createPath:Function;		public var plane:Game.Plane = null;				public function World(_waves:int, _mode:int, _image:BitmapData)		{			waveTarget = _waves;			mode = _mode;						super(_image, initializeComplete, transitionComplete);		}				private function initializeComplete():void		{						towerTick = Tower.tick;			missileTick = Missile.tick;			minionSpawn = Minion.spawn;						// path mode			var pathbg:Bitmap;						if(mode == 0)			{				pathbg = new Bitmap(new Assets.Path(420, 400));				pathbg.x = 0;				pathbg.y = 0;				pathbg.scrollRect = new Rectangle(7, 0, 413, 400);				addChild(pathbg);								minionTick = TDPathBased.tick;				mapCheck = TDPathBased.check;				mapLock = TDPathBased.lock;				mapUnlock = TDPathBased.unlock;				createPath = TDPathBased.createPath;								map = new Vector.<Vector.<AStarNode>>(20, true);				gridSize = 20;				spawnY = 100;								TDPathBased.setup(map);				Wave.IncreaseHitPoints = 165;			}						// free range			else			{				pathbg = new Bitmap(new Assets.EndPoints(420, 400));				pathbg.x = 0;				pathbg.y = 1;				pathbg.scrollRect = new Rectangle(5, 0, 413, 400);				addChild(pathbg);								minionTick = TDFreeBased.tick;				mapCheck = TDFreeBased.check;				mapLock = TDFreeBased.lock;				mapUnlock = TDFreeBased.unlock;				createPath = TDFreeBased.createPath;				map = new Vector.<Vector.<AStarNode>>(20, true);				gridSize = 20;				spawnY = 160;									TDFreeBased.setup(map);				Wave.IncreaseHitPoints = 120;			}			// monster underlay			underlay = new Bitmap();			underlay.x = 10;			underlay.y = 10;			addChild(underlay);			// map clip			mapClip = new MovieClip();			mapClip.x = 10;			mapClip.y = 10;						mapClip.scrollRect = new Rectangle(0, 0, 400, 380);			mapClip.graphics.beginFill(0xFFFFFF, 0.001);			mapClip.graphics.drawRect(0, 0, 400, 380);			mapClip.graphics.endFill();			mapClip.addEventListener(MouseEvent.MOUSE_DOWN, mapClick, false, 0, true);			mapClip.addEventListener(MouseEvent.MOUSE_MOVE, highlightCell, false, 0, true);			addChild(mapClip);						// missile overlay			overlay = new Bitmap();			overlay.x = 10;			overlay.y = 10;			addChild(overlay);					// buttons			nextButton.addEventListener(MouseEvent.CLICK, nextWave, false, 0, true);			pauseButton.addEventListener(MouseEvent.CLICK, togglepause, false, 0, true);			soundButton.addEventListener(MouseEvent.CLICK, toggleSound, false, 0, true);			musicButton.addEventListener(MouseEvent.CLICK, toggleMusic, false, 0, true);			//FastForwardButton.addEventListener(MouseEvent.CLICK, ToggleSpeed, false, 0, true);						// tower buttons							var towerbutton:TowerButton;						for(var i:int=1; i<9; i++)			{											towerbutton = buildMenu["tower" + i] as TowerButton;				towerbutton.config = TowerConfig.List[i - 1];				towerbutton.description.text = "$" + towerbutton.config.price + " " + towerbutton.config.description + " (" + i + ")";				towerbutton.addEventListener(MouseEvent.CLICK, build, false, 0, true);				towerbutton.desc = buttonDescription;				towerbutton.setImage();								towerButtons[i-1] = towerbutton;			}						buttonDescription.visible = false;						if(waveTarget == 10)			{				lives = 5;			}			else if(waveTarget == 50)			{				lives = 10;			}			else if(waveTarget == 100)			{				lives = 20;			}						buildMenu.visible = true;			towerMenu.visible = false;						radius.gotoAndStop(1);			radius2.gotoAndStop(1);			highlight.gotoAndStop(1);			towerMenu.x = 420;			waves = Wave.generate(waveTarget);			waveIndicator.setup(waves);			waveLabel.text = "0/" + waveTarget;						updateMoney(mode == 0 ? 25 : 50);			soundButton.set(SoundManager.SoundOn);			musicButton.set(SoundManager.MusicOn);						if(SoundManager.MusicOn)			{				SoundManager.startMusic();			}						// help			setChildIndex(help, numChildren - 1);			help.closeButton.label.text = "close";			help.closeButton.addEventListener(MouseEvent.CLICK, closeHelp, false, 0, true);			buttonDescription.parent.setChildIndex(buttonDescription, buttonDescription.parent.numChildren - 1);		}						private function closeHelp(e:MouseEvent):void		{			help.parent.removeChild(help);		}				private function transitionComplete():void		{			// game loop and final setup			addEventListener(Event.ENTER_FRAME, tick, false, 0, true);			Main.STAGE.addEventListener(KeyboardEvent.KEY_DOWN, keyDown, false, 0, true);			Main.STAGE.addEventListener(KeyboardEvent.KEY_UP, keyUp, false, 0, true);		}				public function tick(e:Event):void		{					if(pause)				return;							var underlayi:BitmapData = new BitmapData(400, 380, true, 0x00000000);			var overlayi:BitmapData = new BitmapData(400, 380, true, 0x00000000);			towerTick(towers, monsters, missiles);			missileTick(overlayi, missiles, monsters, particles, textBlocks, this);			minionSpawn(waveNumber, waves, monsters, -20, spawnY, map, this);			minionTick(underlayi, monsters, particles, this, map);								Explosion.tick(overlayi, particles);			FadingText.tick(overlayi, textBlocks);			underlay.bitmapData = underlayi;			overlay.bitmapData = overlayi;						livesLabel.text = lives.toString();						if(viewing)			{				towerMenu.update(this);			}						// winning			if(monsters.length == 0 && waves.length == 0 && missiles.length == 0 && particles.length == 0)			{				parent.addChild(new Win(this, Screenshot.create()));				pause = true;				visible = false;				nextButton.enable();				return;			}						// losing			if(lives <= 0)			{				parent.addChild(new Lose(this, Screenshot.create()));				dispose();				return;			}		}				public function dispose():void		{			removeEventListener(Event.ENTER_FRAME, tick, false);			nextButton.removeEventListener(MouseEvent.CLICK, nextWave, false);			pauseButton.removeEventListener(MouseEvent.CLICK, togglepause, false);			soundButton.removeEventListener(MouseEvent.CLICK, toggleSound, false);			musicButton.removeEventListener(MouseEvent.CLICK, toggleMusic, false);			//FastForwardButton.removeEventListener(MouseEvent.CLICK, ToggleSpeed, false);						for each(var towerbutton:TowerButton in towerButtons)				towerbutton.removeEventListener(MouseEvent.CLICK, build, false);						Main.STAGE.removeEventListener(KeyboardEvent.KEY_DOWN, keyDown, false);			Main.STAGE.removeEventListener(KeyboardEvent.KEY_UP, keyUp, false);						while(monsters.length > 0)			{				Minion.dispose(monsters[0]);				monsters.splice(0, 1);						}						while(towers.length > 0)			{				towers[0].target = null				towers[0].parent.removeChild(towers[0]);				towers.splice(0, 1);			}						while(missiles.length > 0)			{				Missile.dispose(missiles[0]);				missiles.splice(0, 1);			}						Main.STAGE.frameRate = 30;			parent.removeChild(this);		}				public function remove(tower:Tower):void		{			textBlocks.push(FadingTextPiece.create("+" + int(tower.spent / 2), tower.x, tower.y, tower.color));			updateMoney(int(tower.spent / 2));						towers.splice(towers.indexOf(tower), 1);			tower.parent.removeChild(tower);			towerMenu.visible = false;			buildMenu.visible = true;			radius2.visible = false;						var gx:int = Math.floor(tower.x / gridSize);			var gy:int = Math.floor(tower.y / gridSize);			mapUnlock(gx, gy, map, monsters);		}				private function build(e:MouseEvent):void		{					if(pause)				return;			var tower:TowerButton = e.target as TowerButton;						if(placing == tower.config.type)			{				placing = 0;				highlight.visible = false;				updateMoney(0);				return;			}						if(money < tower.config.price)				return;							placing = tower.config.type;			updateMoney(0);							if(placing == 0)				return;			towerButtons[placing - 1].background.visible = true;			highlight.visible = false;		}				private function mapClick(e:MouseEvent):void		{			if(pause)				return;							var sx:int = e.stageX;			var sy:int = e.stageY;			var px:int = sx - mapClip.x;			var py:int = sy - mapClip.y;			var gx:int = Math.floor(px / gridSize);			var gy:int = Math.floor(py / gridSize);			var tower:Tower;						// building			if(placing > 0 && mapCheck(gx, gy, map, monsters))			{				SoundManager.play("Click3");				tower = new Tower(placing);				tower.x = gx * gridSize;				tower.y = gy * gridSize;				tower.gridX = gx;				tower.gridY = gy;				tower.centerX = tower.x + 10;				tower.centerY = tower.y + 10;				tower.spent = towerButtons[placing-1].config.price;				tower.addEventListener(MouseEvent.MOUSE_OVER, showRadius, false, 0, true);				tower.addEventListener(MouseEvent.MOUSE_OUT, hideRadius, false, 0, true);				mapClip.addChild(tower);				towers.push(tower);				mapLock(gx, gy, map, monsters);				updateMoney(-tower.spent);				towerMenu.visible = false;				buildMenu.visible = true;				viewing = null;				radius2.visible = false;				selected.visible = false;								if(!shiftDown || money < tower.spent)				{					placing = 0;					highlight.visible = false;					updateMoney(0);				}								if(placing > 0)				{					highlight.visible = true;				}				return;			}			else if(placing > 0)			{				placing = 0;				highlight.visible = false;				updateMoney(0);			}						// show tower			var tx:int = gx * gridSize;			var ty:int = gy * gridSize;						for each(tower in towers)			{				if(tower.x == tx && tower.y == ty)				{					SoundManager.play("Click2");					towerMenu.visible = true;					buildMenu.visible = false;					viewing = tower;					towerMenu.update(this);										radius.visible = false;					radius2.visible = true;					radius2.width = tower.range * 2;					radius2.height = tower.range * 2;					radius2.x = tower.centerX + 10;					radius2.y = tower.centerY + 10;					radius2.gotoAndStop(tower.mColor + 1);					tower.parent.setChildIndex(tower, tower.parent.numChildren - 1);										selected.x = tower.x + 10;					selected.y = tower.y + 10;					selected.gotoAndStop(tower.mColor + 1);					selected.visible = true;					if(placing > 0)					{						placing = 0;						highlight.visible = false;						updateMoney(0);					}					return;				}			}						// reset to build menu			if(placing == 0)			{				highlight.visible = false;				viewing = null;				towerMenu.visible = false;				buildMenu.visible = true;				radius2.visible = false;				selected.visible = false;			}		}						public function updateMoney(add:int):void		{			if(add > 0 || add < 0)			{				money += add;				moneyLabel.text = "$" + money;			}						var towerbutton:TowerButton;						for each(towerbutton in towerButtons)			{				// can't afford				if(towerbutton.config.price > money)				{					towerbutton.alpha = 0.5;					towerbutton.background.visible = false;					if(placing > 0 && towerbutton.config.type == placing)					{						placing = 0;						highlight.visible = false;					}				}								// can afford				else				{					towerbutton.alpha = 1;					towerbutton.background.visible = (placing > 0 && towerbutton.config.type == placing);				}			}		}				// settings		private function togglepause(e:MouseEvent):void		{			SoundManager.play("Click1");			pause = true;			parent.addChild(new Game.Pause(this, Screenshot.create()));		}				private function toggleMusic(e:MouseEvent):void		{			//SoundManager.Play("Click1");			SoundManager.MusicOn = !SoundManager.MusicOn;						if(SoundManager.MusicOn)				SoundManager.startMusic();			else				SoundManager.stopMusic();		}				private function toggleSound(e:MouseEvent):void		{			//SoundManager.Play("Click1");			SoundManager.SoundOn = !SoundManager.SoundOn;		}				private function toggleSpeed(e:MouseEvent):void		{			SoundManager.play("Click1");			Main.STAGE.frameRate = Main.STAGE.frameRate == 30 ? 60 : 30;		}								private function nextWave(e:MouseEvent):void		{			if(pause)				return;							if(waveNumber+1 == waveTarget)				return;			SoundManager.play("Click1");			waveNumber++;			waveLabel.text = (waveNumber + 1).toString() + "/" + waveTarget;						if(waveNumber+1 == waveTarget)				nextButton.disable();							// Here we log the wave progress			Log.LevelCounterMetric("started_" + (mode == 0 ? "path" : "free"), waveNumber);							waveIndicator.jump(waveNumber);		}				// keyboard shortcuts		private function keyDown(e:KeyboardEvent):void		{				if(e.keyCode == Keyboard.SHIFT)			{				shiftDown = true;				return;			}						// building			switch(e.keyCode)			{				case 49: case Keyboard.NUMPAD_1:					towerButtons[0].dispatchEvent(new MouseEvent(MouseEvent.CLICK));					viewing = null;					buildMenu.visible = true;					towerMenu.visible = false;					radius2.visible = false;					selected.visible = false;										return;									case 50: case Keyboard.NUMPAD_2:					towerButtons[1].dispatchEvent(new MouseEvent(MouseEvent.CLICK));					viewing = null;					buildMenu.visible = true;					towerMenu.visible = false;					radius2.visible = false;					selected.visible = false;										return;									case 51: case Keyboard.NUMPAD_3:					towerButtons[2].dispatchEvent(new MouseEvent(MouseEvent.CLICK));					viewing = null;					buildMenu.visible = true;					towerMenu.visible = false;					radius2.visible = false;					selected.visible = false;										return;									case 52: case Keyboard.NUMPAD_4:					towerButtons[3].dispatchEvent(new MouseEvent(MouseEvent.CLICK));					viewing = null;					buildMenu.visible = true;					towerMenu.visible = false;					radius2.visible = false;					selected.visible = false;										return;									case 53: case Keyboard.NUMPAD_5:					towerButtons[4].dispatchEvent(new MouseEvent(MouseEvent.CLICK));					viewing = null;					buildMenu.visible = true;					towerMenu.visible = false;					radius2.visible = false;					selected.visible = false;					return;									case 54: case Keyboard.NUMPAD_6:					towerButtons[5].dispatchEvent(new MouseEvent(MouseEvent.CLICK));					viewing = null;					buildMenu.visible = true;					towerMenu.visible = false;					radius2.visible = false;					selected.visible = false;					return;									case 55: case Keyboard.NUMPAD_7:					towerButtons[6].dispatchEvent(new MouseEvent(MouseEvent.CLICK));					viewing = null;					buildMenu.visible = true;					towerMenu.visible = false;					radius2.visible = false;					selected.visible = false;					return;									case 56: case Keyboard.NUMPAD_8:					towerButtons[7].dispatchEvent(new MouseEvent(MouseEvent.CLICK));					viewing = null;					buildMenu.visible = true;					towerMenu.visible = false;					radius2.visible = false;					selected.visible = false;					return;			}						// tower upgrades/settings			if(viewing == null || towerMenu.visible == false)				return;						switch(e.keyCode)			{				case 82: // [R]ed					towerMenu.red.dispatchEvent(new MouseEvent(MouseEvent.CLICK));					return;									case 71: // [G]reen					towerMenu.green.dispatchEvent(new MouseEvent(MouseEvent.CLICK));					return;									case 66: // [B]lue					towerMenu.blue.dispatchEvent(new MouseEvent(MouseEvent.CLICK));					return;									case 75: // blac[k]					towerMenu.black.dispatchEvent(new MouseEvent(MouseEvent.CLICK));					return;								case 65: // [A]utomatic					towerMenu.automatic.dispatchEvent(new MouseEvent(MouseEvent.CLICK));					return;									case 78: // [N]earest					towerMenu.nearest.dispatchEvent(new MouseEvent(MouseEvent.CLICK));					return;									case 70: // [F]urthest					towerMenu.furthest.dispatchEvent(new MouseEvent(MouseEvent.CLICK));					return;									case 87: // [W]eakest					towerMenu.weakest.dispatchEvent(new MouseEvent(MouseEvent.CLICK));					return;									case 83: // [S]trongest					towerMenu.strongest.dispatchEvent(new MouseEvent(MouseEvent.CLICK));					return;									case 85: // [U]pgrade					towerMenu.upgradeButton.dispatchEvent(new MouseEvent(MouseEvent.CLICK));					return;									case Keyboard.DELETE: // sell					towerMenu.sellButton.dispatchEvent(new MouseEvent(MouseEvent.CLICK));					return;			}		}				private function keyUp(e:KeyboardEvent):void		{			if(e.keyCode == Keyboard.SHIFT)			{				shiftDown = false;					return;			}		}				// radius		private function showRadius(e:MouseEvent):void		{			if(pause)				return;			var tower:Tower = e.target as Tower;						if(viewing == tower)			{				radius.visible = false;				return;			}			radius.visible = true;			radius.width = tower.range * 2;			radius.height = tower.range * 2;			radius.x = tower.centerX + 10;			radius.y = tower.centerY + 10;			radius.gotoAndStop(tower.mColor + 1);						tower.parent.setChildIndex(tower, tower.parent.numChildren - 1);		}		private function hideRadius(e:MouseEvent):void		{			if(pause)				return;			radius.visible = false;		}		// cell highlighting		private function highlightCell(e:MouseEvent):void		{			if(pause)				return;							if(placing == 0)			{				if(highlight.visible)				{					highlight.visible = false;				}									return;			}						var sx:int = e.stageX;			var sy:int = e.stageY;						if(sx < mapClip.x || sx > mapClip.x + mapClip.width || sy < mapClip.y || sy > mapClip.y + mapClip.height)				return;			var px:int = sx - mapClip.x;			var py:int = sy - mapClip.y;			var gx:int = Math.floor(px / gridSize);			var gy:int = Math.floor(py / gridSize);						if(gx < 0 || gx >= map.length || gy < 0 || gy >= map[0].length)			{				if(highlight.visible)				{					highlight.visible = false;				}								return;			}						if(highlight.visible == false)			{				highlight.visible = true;			}						highlight.x = 10 + gx * gridSize;			highlight.y = 10 + gy * gridSize;			if(mapCheck(gx, gy, map, monsters))			{				highlight.gotoAndStop(1);			}			else			{				highlight.gotoAndStop(2);			}		}			}}