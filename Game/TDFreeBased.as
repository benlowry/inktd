package Game{	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.utils.Dictionary;		import Playtomic.Log;	public final class TDFreeBased	{		private static var HealthBars:Vector.<BitmapData> = new Vector.<BitmapData>(17, true);				public static function setup(map:Vector.<Vector.<AStarNode>>):void		{						// buildable cells			var x:int;			var y:int;			for(x=0; x<20; x++)			{				map[x] = new Vector.<AStarNode>(18, true);								for(y=0; y<18; y++)				{					map[x][y] = new AStarNode(x, y, true);				}			}						// health bars			var healthbar:BitmapData;			var healthbar1:Rectangle = new Rectangle(1, 1, 0, 1);			var healthbar2:Rectangle = new Rectangle(0, 0, 18, 3);						for(var i:int=1; i<17; i++)			{				healthbar1.width = i;								healthbar = new BitmapData(18, 3, true, 0x00000000);				healthbar.fillRect(healthbar2, 0x80000000);				healthbar.fillRect(healthbar1, 0xFF66CC66);				HealthBars[i] = healthbar;			}		}				public static function createPath(monster:Minion, map:Vector.<Vector.<AStarNode>>, setindex:Boolean=false):void		{			if(setindex == false)			{				// default starting point				AStar.route(monster, 0, 8 + monster.startOffset, 19, 8 + monster.startOffset, map);				monster.path.reverse();			}			else			{				AStar.route(monster, monster.gridX, monster.gridY, 19, 8 + monster.startOffset, map);				monster.path.reverse();				var p2:Point;				var i:int = 0;								for each(p2 in monster.path)				{					if(p2.x == monster.gridX && p2.y == monster.gridY)					{						monster.pathIndex = i+1;						break;					}										i++;				}			}		}				// for normal monsters		private static function createPath2(monster:Minion, map:Vector.<Vector.<AStarNode>>):void		{			if(monster.gridX > 19)						{				return;			}			else			{				AStar.route(monster, monster.gridX, monster.gridY, 19, 8 + monster.startOffset, map);				monster.path.reverse();			}		}				// for flying monsters		public static function createPath3(monster:Minion, map:Vector.<Vector.<AStarNode>>):void		{			monster.path = new Vector.<Point>(20 - monster.gridX);			var i:int = 0;						for(var x:int=monster.gridX+1; x<21; x++)			{				monster.path[i] = new Point(x, 8 + monster.startOffset);				i++;			}		}						public static function check(gx:int, gy:int, map:Vector.<Vector.<AStarNode>>, monsters:Vector.<Minion>):Boolean		{			if(gx < 0 || gy < 0 || gx >= map.length || gy >= map[0].length)				return false;							if(map[gx][gy].Walkable == false)				return false;							// reserved squares			if((gx == 0 && gy == 8) || (gx == 1 && gy == 8) || (gx == 18 && gy == 8) || (gx == 19 && gy == 8))			   	return false;							// check monsters on path							var monster:Minion							for each(monster in monsters)			{				if(monster.gridX == gx && monster.gridY == gy)				{					return false;				}			}			// check a path exists			map[gx][gy].Walkable = false;						var defaultpath:Vector.<Point> = AStar.check(0, 8, 19, 8, map);					map[gx][gy].Walkable = true;						if(defaultpath.length == 0 || (defaultpath[0].x != 19 || defaultpath[0].y != 8))				return false;			return true;		}				public static function lock(gx:int, gy:int, map:Vector.<Vector.<AStarNode>>, monsters:Vector.<Minion>):void		{			map[gx][gy].Walkable = false;		}				public static function unlock(gx:int, gy:int, map:Vector.<Vector.<AStarNode>>, monsters:Vector.<Minion>):void		{			map[gx][gy].Walkable = true;		}		public static function tick(image:BitmapData, monsters:Vector.<Minion>, particles:Vector.<ExplosionPiece>, world:Game.World, map:Vector.<Vector.<AStarNode>>):void		{						if(monsters.length == 0)				return;							var gx:int;			var gy:int;			var nextpath:int;			var monster:Minion;			var monster2:Minion;			var p:Point = new Point();			var zeropoint:Point = new Point();			var healthbar:BitmapData;			for(var i:int=monsters.length-1; i>-1; i--)			{								monster = monsters[i];									// Here we log the lead monster's progress on our heatmap				if(i == 0)				{					Log.Heatmap("monstermove_free_" + world.waveNumber, "monster_progress", monster.centerX, monster.centerY);				}								// respawning				if(monster.dead)				{					p.x = monster.x;					p.y = monster.y;					image.copyPixels(monster.image, monster.image.rect, p, null, null, true);										Minion.respawn(monster, particles);					continue;				}								// process move				monster.x += monster.moveX;				monster.y += monster.moveY;				monster.centerX = monster.x + 10;				monster.centerY = monster.y + 10;				monster.moved += monster.speed;								p.x = monster.x;				p.y = monster.y;								healthbar = HealthBars[Math.ceil((monster.hitPoints / monster.hitPointsBase) * 16)];				// check for path change				if(monster.moved < 20)				{					image.copyPixels(monster.image, monster.image.rect, p, null, null, true);					image.copyPixels(healthbar, healthbar.rect, p, null, null, true);					continue;				}								monster.moved = 0;				gx = monster.x / 20;				gy = monster.y / 20;				nextpath = monster.pathIndex + 1;								monster.gridX = gx;				monster.gridY = gy;								// monster left map				if(monster.gridX > 20)				{					Minion.escape(world, monster);					monsters.splice(i, 1);					continue;				}				// walking to next path				if(monster.flies == false)				{					createPath2(monster, map);					monster.pathIndex = 0;				}								// flying to next path				else				{					createPath3(monster, map);				}								Minion.setDirection(monster);								// render				p.x = monster.x;				p.y = monster.y;				image.copyPixels(monster.image, monster.image.rect, p, null, null, true);				image.copyPixels(healthbar, healthbar.rect, p, null, null, true);			}		}	}}