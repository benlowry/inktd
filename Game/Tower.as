package Game{	import flash.display.Sprite;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.geom.Point;	import flash.geom.Rectangle;		public final class Tower extends Sprite	{		public static var Blue:Vector.<Class> = new Vector.<Class>(8, true);		public static var Red:Vector.<Class> = new Vector.<Class>(7, true);		public static var Green:Vector.<Class> = new Vector.<Class>(7, true);		public static var Black:Vector.<Class> = new Vector.<Class>(7, true);				public var imageContainer:Sprite;		public var image:Sprite;		public var firePause:int = 0;		public var config:TowerConfig;		public var missileImage:BitmapData = Missile.Blue;		public var type:int;		public var color:uint = 0;		public var mColor:int;		public var centerX:int;		public var centerY:int;		public var gridX:int;		public var gridY:int;		public var targetingMode:int = 0;		public var range:int;		public var gridRange:int;		public var speed:int;				public var level:int = 1;		public var damage:int = 0;		public var target:Minion;				public var spent:int;		public var kills:int = 0;				public function Tower(_type:int)		{			config = TowerConfig.List[_type-1];			color = ColorModes.Blue;			mColor = 0;			type = _type;			range = config.range;			gridRange = Math.ceil(range / 20);			speed = config.speed;			damage = config.damage;						imageContainer = new Sprite();			imageContainer.x = 10;			imageContainer.y = 10;			addChild(imageContainer);						image = new Blue[type-1]();			image.x = -10;			image.y = -10;			image.cacheAsBitmap = true;			imageContainer.addChild(image);						useHandCursor = true;			buttonMode = true;			mouseChildren = false;					}				public function setColor(_color:uint):void		{			color = _color;			imageContainer.removeChildAt(0);						switch(color)			{				case ColorModes.Blue:					image = new Blue[type-1]();					missileImage = Missile.Blue;					mColor = 0;					break;									case ColorModes.Red:					image = new Red[type-1]();					missileImage = Missile.Red;					mColor = 1;					break;									case ColorModes.Black:					image = new Black[type-1]();					missileImage = Missile.Black;					mColor = 2;					break;									case ColorModes.Green:					image = new Green[type-1]();					missileImage = Missile.Green;					mColor = 3;					break;								}						image.x = -10;			image.y = -10;			imageContainer.addChild(image);		}				public static function tick(towers:Vector.<Tower>, monsters:Vector.<Minion>, missiles:Vector.<Missile>):void		{			if(towers.length == 0 || monsters.length == 0)				return;							// general stuff			var tower:Tower;			var i:int;			var j:int;			var d:Number;			var d2:Number;			var dx:Number;			var dy:Number;			var dx2:Number;			var dy2:Number;						// targetting stuff			var monster:Minion;				var compare:int;			var monsterhp:int;			var monsterhits:int;			var damage:int;			var range:int;			var gx:int;			var gy:int;			var abs:Function = Math.abs;						for(i=towers.length-1; i>-1; i--)			{				tower = towers[i];								if(tower.imageContainer.x != 10)				{					tower.imageContainer.x++;					tower.imageContainer.y++;				}								// check if existing target is out of range now				if(tower.target != null)				{					if(tower.target.dead)					{						tower.target = null;					}					else					{						dx = tower.target.centerX - tower.centerX;						dy = tower.target.centerY - tower.centerY;						d = Math.sqrt((dx * dx) + (dy * dy));																			if(d > tower.range)						{							tower.target = null;						}					}				}								// aquire new target				if(tower.target == null || tower.targetingMode != TargetModes.Automatic)				{					compare = -1;					damage = tower.damage;					range = tower.range;										switch(tower.targetingMode)					{						case TargetModes.Automatic:													for each(monster in monsters)							{								// valid target								if(monster.dead || (monster.color != tower.color && tower.type != 8))									continue;																	// grid range check								gx = abs(monster.gridX - tower.gridX);								gy = abs(monster.gridY - tower.gridY);																if(gx > tower.gridRange || gy > tower.gridRange)									continue;												// range check								dx = monster.centerX - tower.centerX;								dy = monster.centerY - tower.centerY;								d = Math.sqrt((dx * dx) + (dy * dy));																if(d > range)									continue;																// comparison								monsterhp = monster.hitPoints;								monsterhits = 1 + int(monsterhp / damage);												if(compare == -1 || monsterhits < compare)								{									tower.target = monster;									compare = monsterhits;								}							}														break;													case TargetModes.Nearest:													for each(monster in monsters)							{								// valid target								if(monster.dead || (monster.color != tower.color && tower.type != 8))									continue;																	// grid range check								gx = abs(monster.gridX - tower.gridX);								gy = abs(monster.gridY - tower.gridY);																if(gx > tower.gridRange || gy > tower.gridRange)									continue;												// range check								dx = monster.centerX - tower.centerX;								dy = monster.centerY - tower.centerY;								d = Math.sqrt((dx * dx) + (dy * dy));																if(d > range)									continue;																// comparison								monsterhp = monster.hitPoints;								monsterhits = 1 + int(monsterhp / damage);												if(compare == -1 || d < compare)								{									tower.target = monster;									compare = d;																}							}													break;													case TargetModes.Furthest:													for each(monster in monsters)							{								// valid target								if(monster.dead || (monster.color != tower.color && tower.type != 8))									continue;																	// grid range check								gx = abs(monster.gridX - tower.gridX);								gy = abs(monster.gridY - tower.gridY);																if(gx > tower.gridRange || gy > tower.gridRange)									continue;																					// range check								dx = monster.centerX - tower.centerX;								dy = monster.centerY - tower.centerY;								d = Math.sqrt((dx * dx) + (dy * dy));																if(d > range)									continue;																// comparison								monsterhp = monster.hitPoints;								monsterhits = 1 + int(monsterhp / damage);												if(compare == -1 || d > compare)								{									tower.target = monster;									compare = d;																}							}														break;													case TargetModes.Weakest:													for each(monster in monsters)							{								// valid target								if(monster.dead || (monster.color != tower.color && tower.type != 8))									continue;																	// grid range check								gx = abs(monster.gridX - tower.gridX);								gy = abs(monster.gridY - tower.gridY);																if(gx > tower.gridRange || gy > tower.gridRange)									continue;																					// range check								dx = monster.centerX - tower.centerX;								dy = monster.centerY - tower.centerY;								d = Math.sqrt((dx * dx) + (dy * dy));																if(d > range)									continue;																// comparison								monsterhp = monster.hitPoints;								monsterhits = 1 + int(monsterhp / damage);												if(compare == -1 || monster.hitPoints < compare)								{									tower.target = monster;									compare = monster.hitPoints;																}							}													break;													case TargetModes.Strongest:													for each(monster in monsters)							{								// valid target								if(monster.dead || (monster.color != tower.color && tower.type != 8))									continue;																	// grid range check								gx = abs(monster.gridX - tower.gridX);								gy = abs(monster.gridY - tower.gridY);																if(gx > tower.gridRange || gy > tower.gridRange)									continue;																					// range check								dx = monster.centerX - tower.centerX;								dy = monster.centerY - tower.centerY;								d = Math.sqrt((dx * dx) + (dy * dy));																if(d > range)									continue;																// comparison								monsterhp = monster.hitPoints;								monsterhits = 1 + int(monsterhp / damage);												if(compare == -1 || monster.hitPoints > compare)								{									tower.target = monster;									compare = monster.hitPoints;																}							}													break;					}				}								if(tower.target != null)				{					d = Math.atan2(tower.target.centerY - tower.centerY, tower.target.centerX - tower.centerX);					tower.imageContainer.rotation = d * (180 / Math.PI) + 90;				}								// firing delay				if(tower.firePause > 0)				{					tower.firePause--;					continue;				}								if(tower.target == null)					continue;											// tower firing				tower.firePause = tower.speed;				tower.imageContainer.x = 9;				tower.imageContainer.y = 9;								if(tower.config.behaviorType == BehaviorTypes.Normal)				{								SoundManager.play("Fire1");					missiles.push(Missile.create(tower, tower.target));				}				else if(tower.config.behaviorType == BehaviorTypes.Multi2)				{					SoundManager.play("Fire2");					missiles.push(Missile.create(tower, tower.target, 3));					missiles.push(Missile.create(tower, tower.target, -3));				}				else if(tower.config.behaviorType == BehaviorTypes.Multi3)				{					SoundManager.play("Fire2");					missiles.push(Missile.create(tower, tower.target, 4));					missiles.push(Missile.create(tower, tower.target));											missiles.push(Missile.create(tower, tower.target, -4));				}				else if(tower.config.behaviorType == BehaviorTypes.Spray)				{					SoundManager.play("Fire3");					missiles.push(Missile.create(tower, tower.target, 0, 1));						missiles.push(Missile.create(tower, tower.target, 0, 2));						missiles.push(Missile.create(tower, tower.target, 0, 3));						missiles.push(Missile.create(tower, tower.target, 0, 4));						missiles.push(Missile.create(tower, tower.target, 0, 5));						missiles.push(Missile.create(tower, tower.target, 0, 6));						missiles.push(Missile.create(tower, tower.target, 0, 7));						missiles.push(Missile.create(tower, tower.target, 0, 8));				}			}		}				// old targetting methodology		/*private static function findMonstersInRange(tower:Tower, monsters:Vector.<Minion>):void		{			while(tower.InRange.length > 0)				tower.InRange.splice(0, 1);						var monster:Minion;			var dx:Number;			var dy:Number;			var d:Number;						for each(monster in monsters)			{				if(monster.dead || (monster.color != tower.color && tower.type != 8))					continue;				dx = monster.centerX - tower.centerX;				dy = monster.centerY - tower.centerY;				d = Math.sqrt((dx * dx) + (dy * dy));								if(d > tower.range)					continue;				tower.InRange.push(monster);			}		}		private static function findAutomaticTarget(tower:Tower):void		{			var compare:int = -1;			var monster:Minion;			var monsterhp:int;			var monsterhits:int;			var result:Minion = tower.InRange[0];			var damage:int = tower.damage;						for each(monster in tower)			{								monsterhp = monster.hitPoints;				monsterhits = 1 + int(monsterhp / damage);				if(compare == -1 || monsterhits < compare)				{					result = monster;					compare = monsterhits;				}			}			tower.target = result;		}				private static function findNearestTarget(tower:Tower):void		{			var compare:int = -1;			var monster:Minion;			var result:Minion = tower.InRange[0];			var dx:Number;			var dy:Number;			var d:Number;									for each(monster in tower.InRange)			{								dx = monster.centerX - tower.centerX;				dy = monster.centerY - tower.centerY;				d = Math.sqrt((dx * dx) + (dy * dy));									if(compare == -1 || d < compare)				{					result = monster;					compare = d;												}			}			tower.target = result;		}				private static function findFurthestTarget(tower:Tower):void		{			var compare:int = -1;			var monster:Minion;			var result:Minion = tower.InRange[0];			var dx:Number;			var dy:Number;			var d:Number;								for each(monster in tower.InRange)			{								dx = monster.centerX - tower.centerX;				dy = monster.centerY - tower.centerY;				d = Math.sqrt((dx * dx) + (dy * dy));									if(compare == -1 || d > compare)				{					result = monster;					compare = d;												}			}			tower.target = result;		}				private static function findWeakestTarget(tower:Tower):void		{			var compare:int = -1;			var monster:Minion;			var result:Minion = tower.InRange[0];			for each(monster in tower.InRange)			{					if(compare == -1 || monster.hitPoints < compare)				{					result = monster;					compare = monster.hitPoints;												}			}			tower.target = result;		}				private static function findStrongestTarget(tower:Tower):void		{			var compare:int = -1;			var monster:Minion;			var result:Minion = tower.InRange[0];			for each(monster in tower.InRange)			{				if(compare == -1 || monster.hitPoints > compare)				{					result = monster;					compare = monster.hitPoints;												}			}			tower.target = result;		}*/				public static function initialize():void		{			Blue[0] = TowerBlue1;			Blue[1] = TowerBlue2;			Blue[2] = TowerBlue3;			Blue[3] = TowerBlue4;			Blue[4] = TowerBlue7;			Blue[5] = TowerBlue5;			Blue[6] = TowerBlue6;			Blue[7] = TowerBlue8;									Red[0] = TowerRed1;			Red[1] = TowerRed2;			Red[2] = TowerRed3;			Red[3] = TowerRed4;			Red[4] = TowerRed7;			Red[5] = TowerRed5;				Red[6] = TowerRed6;							Black[0] = TowerBlack1;			Black[1] = TowerBlack2;			Black[2] = TowerBlack3;			Black[3] = TowerBlack4;			Black[4] = TowerBlack7;			Black[5] = TowerBlack5;			Black[6] = TowerBlack6;							Green[0] = TowerGreen1;			Green[1] = TowerGreen2;			Green[2] = TowerGreen3;			Green[3] = TowerGreen4;			Green[4] = TowerGreen7;			Green[5] = TowerGreen5;			Green[6] = TowerGreen6;			}			}}