package Game{	import flash.geom.Point;	public final class AStar	{		private static var Pool:Vector.<Point> = new Vector.<Point>();		private static const COST_ORTHOGONAL:Number = 1;		//private static const COST_DIAGONAL:Number = COST_ORTHOGONAL * Math.sqrt(2);				public static function route(monster:Minion, sx:int, sy:int, dx:int, dy:int, map:Vector.<Vector.<AStarNode>>):void		{			var width:int = map.length;			var height:int = map[0].length;			var open:Vector.<AStarNode> = new Vector.<AStarNode>();			var closed:Vector.<AStarNode> = new Vector.<AStarNode>();			var goal:AStarNode = map[dx][dy];			var start:AStarNode = map[sx][sy];			start.G = 0;			start.H = distance(start, goal);			start.F = start.H;			start.Parent = null;			open.push(start);			var f:Number;			var x:AStarNode;			var y:AStarNode;			var i:int;			var nneighbours:Vector.<AStarNode>;						var attempts:int = 0;						while(open.length > 0 && attempts < 20000) 			{				attempts++;				f = Number.POSITIVE_INFINITY;								for (i=0; i<open.length; i++) 				{					if (open[i].F < f)					{						x = open[i];						f = x.F;					}				}								if (x == goal) 				{					reconstructPath(monster, goal);					return;				}								open.splice(open.indexOf(x), 1);				closed.push(x);				nneighbours = neighbors(x, map, width, height);								for each (y in nneighbours) 				{					if (closed.indexOf(y) > -1)						continue;										var g:Number = x.G + y.TravelCost;					var better:Boolean = false;										if (open.indexOf(y) == -1)					{						open.push(y);						better = true;					} 					else if (g < y.G) 					{						better = true;					}										if (better) 					{						y.Parent = x;						y.G = g;						y.H = distance(y, goal);						y.F = y.G + y.H;					}				}			}			var min:Number = Number.POSITIVE_INFINITY;			var n:AStarNode;			var ng:AStarNode;			var dist:Number						for each(n in closed) 			{				dist = distance(goal, n);								if (dist < min) 				{					min = dist;					ng = n;				}			}						reconstructPath(monster, ng);		}				public static function check(sx:int, sy:int, dx:int, dy:int, map:Vector.<Vector.<AStarNode>>):Vector.<Point>		{			var width:int = map.length;			var height:int = map[0].length;			var open:Vector.<AStarNode> = new Vector.<AStarNode>();			var closed:Vector.<AStarNode> = new Vector.<AStarNode>();			var goal:AStarNode = map[dx][dy];						var start:AStarNode = map[sx][sy];			start.G = 0;			start.H = distance(start, goal);			start.F = start.H;			start.Parent = null;			open.push(start);			var f:Number;			var x:AStarNode;			var y:AStarNode;			var i:int;			var neighbours:Vector.<AStarNode>;						var attempts:int = 0;						while(open.length > 0 && attempts < 20000) 			{				attempts++;				f = Number.POSITIVE_INFINITY;								for (i=0; i<open.length; i++) 				{					if (open[i].F < f)					{						x = open[i];						f = x.F;					}				}								if (x == goal) 				{					return reconstructPath2(goal);				}								open.splice(open.indexOf(x), 1);				closed.push(x);				neighbours = neighbors(x, map, width, height);								for each (y in neighbours) 				{					if (closed.indexOf(y) > -1)						continue;										var g:Number = x.G + y.TravelCost;					var better:Boolean = false;										if (open.indexOf(y) == -1)					{						open.push(y);						better = true;					} 					else if (g < y.G) 					{						better = true;					}										if (better) 					{						y.Parent = x;						y.G = g;						y.H = distance(y, goal);						y.F = y.G + y.H;					}				}			}			var min:Number = Number.POSITIVE_INFINITY;			var n:AStarNode;			var ng:AStarNode;			var dist:Number						for each(n in closed) 			{				dist = distance(goal, n);								if (dist < min) 				{					min = dist;					ng = n;				}			}						return reconstructPath2(ng);		}				private static function reconstructPath(monster:Minion, n:AStarNode):void		{			if(monster.path == null)			{				monster.path = new Vector.<Point>();			}			else			{				while(monster.path.length > 0)				{					Pool.push(monster.path[0]);					monster.path.splice(0, 1);				}			}						var nn:AStarNode = n;			var p:Point;						while(nn.Parent) 			{				p = Pool.length > 0 ? Pool.pop() : new Point();				p.x = nn.X;				p.y = nn.Y;								monster.path.push(p);				nn = nn.Parent;			}						p = Pool.length > 0 ? Pool.pop() : new Point();			p.x = 20;			p.y = 8 + monster.startOffset;						monster.path.splice(0, 0, p);						return;		}				private static function reconstructPath2(n:AStarNode):Vector.<Point> 		{			var solution:Vector.<Point> = new Vector.<Point>();			var nn:AStarNode = n;			var p:Point;						while(nn.Parent) 			{				p = Pool.length > 0 ? Pool.pop() : new Point();				p.x = nn.X;				p.y = nn.Y;								solution.push(p);				nn = nn.Parent;			}						return solution;		}		private static function distance(n1:AStarNode, n2:AStarNode):Number 		{			return Math.abs(n1.X - n2.X) + Math.abs(n1.Y - n2.Y);		}		private static function neighbors(node:AStarNode, map:Vector.<Vector.<AStarNode>>, width:int, height:int):Vector.<AStarNode>		{			var x:int = node.X;			var y:int = node.Y;			var n:AStarNode;			var a:Vector.<AStarNode> = new Vector.<AStarNode>();						// N			if (x > 0) 			{								n = map[x-1][y];								if (n.Walkable) 				{					n.TravelCost = COST_ORTHOGONAL;					a.push(n);				}			}						// E			if (x < width-1) 			{				n = map[x+1][y];								if (n.Walkable) 				{					n.TravelCost = COST_ORTHOGONAL;					a.push(n);				}			} 						// N			if (y > 0) 			{				n = map[x][y-1];								if (n.Walkable) 				{					n.TravelCost = COST_ORTHOGONAL;					a.push(n);				}			}						// S			if (y < height-1) 			{				n = map[x][y+1];				if (n.Walkable) 				{					n.TravelCost = COST_ORTHOGONAL;					a.push(n);				}			}			// NW			/*if (x > 0 && y > 0) 			{				n = map[x-1][y-1];								if (n.Walkable && map[x-1][y].Walkable && map[x][y-1].Walkable) 				{					n.TravelCost = COST_DIAGONAL;					a.push(n);				}			}						// NE			if (x < width-1 && y > 0) 			{				n = map[x+1][y-1];								if (n.Walkable && map[x+1][y].Walkable && map[x][y-1].Walkable)				{					n.TravelCost = COST_DIAGONAL;					a.push(n);				}			}						// SW			if (x > 0 && y < height-1) 			{				n = map[x-1][y+1];								if (n.Walkable && map[x-1][y].Walkable && map[x][y+1].Walkable) 				{					n.TravelCost = COST_DIAGONAL;					a.push(n);				}			}						// SE			if (x < width-1 && y < height-1) 			{				n = map[x+1][y+1];								if (n.Walkable && map[x+1][y].Walkable && map[x][y+1].Walkable) 				{					n.TravelCost = COST_DIAGONAL;					a.push(n);				}			}*/						//trace("neighbours: " + a);						return a;		}	}}