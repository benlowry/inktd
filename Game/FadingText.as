package Game{	import flash.display.BitmapData;	import flash.text.TextField;	import flash.text.TextFormat;	import flash.text.TextFieldAutoSize;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.filters.ColorMatrixFilter;	import flash.utils.Dictionary;		public final class FadingText	{		private static var cache:Dictionary = new Dictionary();		private static const opacity:ColorMatrixFilter = new ColorMatrixFilter();		private static const opacityArray:Array = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0];		private static const zeroPoint:Point = new Point(0, 0);		private static const text:TextField = new TextField();				public static function initialize():void		{			var format:TextFormat = new TextFormat();			format.font = new Font1().fontName;			format.size = 12;			format.bold = true;			format.color = 0x336699;						text.defaultTextFormat = format;			text.autoSize = TextFieldAutoSize.LEFT;			text.embedFonts = true;		}		public static function tick(image:BitmapData, pieces:Vector.<FadingTextPiece>):void		{			if(pieces.length == 0)				return;			var textblock:FadingTextPiece;			var textimage:BitmapData = new BitmapData(50, 20, true, 0x00000000);			var copypoint:Point = new Point();			var key:String;							for(var i:int=pieces.length-1; i>-1; i--)			{				textblock = pieces[i];				textblock.countDown--;								// finished				if(textblock.countDown == 0)				{					pieces.splice(i, 1);					FadingTextPiece.dispose(textblock);					continue;				}								// moving up				if(textblock.countDown < 33)				{					textblock.position.y--;					textblock.opacity -= 3;				}								// setup				key = textblock.message + "_" + textblock.color + "_" + textblock.opacity;								if(cache[key])				{					textimage = cache[key];				}				else				{					text.text = textblock.message;					text.textColor = textblock.color;										opacityArray[18] = textblock.opacity / 100;					opacity.matrix = opacityArray;										var newimage:BitmapData = new BitmapData(text.width, 20, true, 0x00000000);					newimage.fillRect(image.rect, 0x00000000);					newimage.draw(text);					newimage.applyFilter(newimage, newimage.rect, zeroPoint, opacity);										cache[key] = newimage;					textimage = newimage;				}				copypoint.x = textblock.position.x - (textimage.width / 2);				copypoint.y = textblock.position.y - (textimage.height / 2);				image.copyPixels(textimage, textimage.rect, copypoint, null, null, true);			}		}	}}