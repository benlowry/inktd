package Game{	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.geom.Point;	import flash.geom.Rectangle;		import Playtomic.Log;	public final class TDPathBased	{			private static const MapTemplate:Array = 			["xxxxxxxxxxxxxxxxxxxx",			 "xxxxxxxxxxxxxxxxxxxx",			 "xxxxxxx-----------xx",			 "xxxxxxx-xxxxxxxxx-xx",			 "xxxxxxx-xxxxxxxxx-xx",			 "--------xxxxxxxxx-xx",			 "xxxxxxxxxxxxxxxxx-xx",			 "xxxxxxxxxxxxxxxxx-xx",			 "xxxxxxxxxxxxxxxxx-xx",			 "xxxxxxxxxxxxxxxxx-xx",				 "xxxxxxxxxxxxxxxxx-xx",			 "xxxxxxxxxxxxxxxxx-xx",			 "xxx---------------xx",			 "xxx-xxxxxxxxxxxxxxxx",			 "xxx-xxxxxxxxxxxxxxxx",			 "xxx-xxxxxxxxxxxxxxxx",				 "xxx-----------------",			 "xxxxxxxxxxxxxxxxxxxx",			 			 "xxxxxxxxxxxxxxxxxxxx"];	 					private static var HealthBars:Vector.<BitmapData> = new Vector.<BitmapData>(17, true);				private static const DefaultPath:Vector.<Point> = new Vector.<Point>(65);		DefaultPath[0] = new Point(0, 5);		DefaultPath[1] = new Point(1, 5);		DefaultPath[2] = new Point(2, 5);		DefaultPath[3] = new Point(3, 5);		DefaultPath[4] = new Point(4, 5);		DefaultPath[5] = new Point(5, 5);		DefaultPath[6] = new Point(6, 5);		DefaultPath[7] = new Point(7, 5);		DefaultPath[8] = new Point(7, 4);		DefaultPath[9] = new Point(7, 3);		DefaultPath[10] = new Point(7, 2);		DefaultPath[11] = new Point(8, 2);		DefaultPath[12] = new Point(9, 2);		DefaultPath[13] = new Point(10, 2);		DefaultPath[14] = new Point(11, 2);		DefaultPath[15] = new Point(12, 2);		DefaultPath[16] = new Point(13, 2);		DefaultPath[17] = new Point(14, 2);		DefaultPath[18] = new Point(15, 2);		DefaultPath[19] = new Point(16, 2);		DefaultPath[20] = new Point(17, 2);		DefaultPath[21] = new Point(17, 3);		DefaultPath[22] = new Point(17, 4);		DefaultPath[23] = new Point(17, 5);		DefaultPath[24] = new Point(17, 6);		DefaultPath[25] = new Point(17, 7);		DefaultPath[26] = new Point(17, 8);		DefaultPath[27] = new Point(17, 9);		DefaultPath[28] = new Point(17, 10);		DefaultPath[29] = new Point(17, 11);		DefaultPath[30] = new Point(17, 12);		DefaultPath[31] = new Point(16, 12);		DefaultPath[32] = new Point(15, 12);		DefaultPath[33] = new Point(14, 12);		DefaultPath[34] = new Point(13, 12);		DefaultPath[35] = new Point(12, 12);		DefaultPath[36] = new Point(11, 12);		DefaultPath[37] = new Point(10, 12);		DefaultPath[38] = new Point(9, 12);		DefaultPath[39] = new Point(8, 12);		DefaultPath[40] = new Point(7, 12);		DefaultPath[41] = new Point(6, 12);		DefaultPath[42] = new Point(5, 12);		DefaultPath[43] = new Point(4, 12);		DefaultPath[44] = new Point(3, 12);		DefaultPath[45] = new Point(3, 13);		DefaultPath[46] = new Point(3, 14);		DefaultPath[47] = new Point(3, 15);		DefaultPath[48] = new Point(3, 16);		DefaultPath[49] = new Point(4, 16);		DefaultPath[50] = new Point(5, 16);		DefaultPath[51] = new Point(6, 16);		DefaultPath[52] = new Point(7, 16);		DefaultPath[53] = new Point(8, 16);		DefaultPath[54] = new Point(9, 16);		DefaultPath[55] = new Point(10, 16);		DefaultPath[56] = new Point(11, 16);		DefaultPath[57] = new Point(12, 16);		DefaultPath[58] = new Point(13, 16);		DefaultPath[59] = new Point(14, 16);		DefaultPath[60] = new Point(15, 16);		DefaultPath[61] = new Point(16, 16);		DefaultPath[62] = new Point(17, 16);		DefaultPath[63] = new Point(18, 16);		DefaultPath[64] = new Point(19, 16);						public static function setup(map:Vector.<Vector.<AStarNode>>):void		{									// buildable cells			var str:String;			var x:int;			var y:int;						for(x=0; x<20; x++)			{				map[x] = new Vector.<AStarNode>(18, true);				for(y=0; y<18; y++)				{					str = MapTemplate[y].charAt(x);					map[x][y] = new AStarNode(x, y, str == "x");				}			}						// health bars						var healthbar:BitmapData;			var healthbar1:Rectangle = new Rectangle(1, 1, 0, 1);			var healthbar2:Rectangle = new Rectangle(0, 0, 18, 3);						for(var i:int=1; i<17; i++)			{				healthbar1.width = i;								healthbar = new BitmapData(18, 3, true, 0x00000000);				healthbar.fillRect(healthbar2, 0x80000000);				healthbar.fillRect(healthbar1, 0xFF66CC66);				HealthBars[i] = healthbar;			}		}				public static function createPath(monster:Minion, map:Vector.<Vector.<AStarNode>>, setindex:Boolean=false):void		{			monster.path = DefaultPath;						if(setindex == false)				return;			var p2:Point;			var i:int = 0;						for each(p2 in monster.path)			{				if(p2.x == monster.gridX && p2.y == monster.gridY)				{					monster.pathIndex = i+1;					break;				}								i++;			}		}				public static function check(gx:int, gy:int, map:Vector.<Vector.<AStarNode>>, monsters:Vector.<Minion>):Boolean		{			if(gx < 0 || gy < 0 || gx >= map.length || gy >= map[0].length)				return false;			return map[gx][gy].Walkable;		}				public static function lock(gx:int, gy:int, map:Vector.<Vector.<AStarNode>>, monsters:Vector.<Minion>):void		{			map[gx][gy].Walkable = false;		}				public static function unlock(gx:int, gy:int, map:Vector.<Vector.<AStarNode>>, monsters:Vector.<Minion>):void		{			map[gx][gy].Walkable = true;		}		public static function tick(image:BitmapData, monsters:Vector.<Minion>, particles:Vector.<ExplosionPiece>, world:Game.World, map:Vector.<Vector.<AStarNode>>):void		{						if(monsters.length == 0)				return;							var gx:int;			var gy:int;			var nextpath:int;			var monster:Minion;			var monster2:Minion;			var p:Point = new Point();			var zeropoint:Point = new Point();			var healthbar:BitmapData;			for(var i:int=monsters.length-1; i>-1; i--)			{								monster = monsters[i];										// Here we log the lead monster's progress on our heatmap				if(i == 0)				{					Log.Heatmap("monstermove_path_" + world.waveNumber, "monster_progress", monster.centerX, monster.centerY);				}								// respawning				if(monster.dead)				{					p.x = monster.x;					p.y = monster.y;					image.copyPixels(monster.image, monster.image.rect, p, null, null, true);										Minion.respawn(monster, particles);					continue;				}								// process move				monster.x += monster.moveX;				monster.y += monster.moveY;				monster.centerX = monster.x + 10;				monster.centerY = monster.y + 10;				monster.moved += monster.speed;								p.x = monster.x;				p.y = monster.y;								healthbar = HealthBars[Math.ceil((monster.hitPoints / monster.hitPointsBase) * 16)];				// check for path change				if(monster.moved < 20)				{					image.copyPixels(monster.image, monster.image.rect, p, null, null, true);					image.copyPixels(healthbar, healthbar.rect, p, null, null, true);					continue;				}								monster.moved = 0;				gx = monster.x / 20;				gy = monster.y / 20;				monster.gridX = gx;				monster.gridY = gy;				nextpath = monster.pathIndex + 1;								// monster left map				if(monster.gridX > 20)				{					Minion.escape(world, monster);					monsters.splice(i, 1);					continue;				}								monster.pathIndex = nextpath;				Minion.setDirection(monster, nextpath);								// render				p.x = monster.x;				p.y = monster.y;				image.copyPixels(monster.image, monster.image.rect, p, null, null, true);				image.copyPixels(healthbar, healthbar.rect, p, null, null, true);			}		}	}}